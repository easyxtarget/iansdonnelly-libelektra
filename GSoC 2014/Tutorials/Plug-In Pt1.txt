First of all, all plug-ins use the same basic interface. This interface consists of five basic functions, elektraPluginOpen, elektraPluginGet, elektraPluginSet, elektraPluginError, and elektraPluginClose. Normally, the developer would replace 'Plugin' with the name of their plugin. So in the case of my plugin, the names of these functions would be elektraLineOpen(), elektraLineGet(), elektraLineSet(), elektraLineError(), and elektraLineClose().

The kdb class relies on these functions for interacting with configuration files stored in the key database. A call to kdbOpen() will call the elektraPluginOpen() function for the plugin that was used to mount the configuration data. Similarly, calls for kdbGet() and kdbClose() will call the functions elektraPluginGet() and elektraPluginClose() respectively. The only exception is kdbSet() which calls elektraPluginSet() but also elektraPluginError() when an error occurs. The functions serve different purposes.

elektraPluginOpen() is designed to allow each plug-in to do initialization if necessary.

elektraPluginGet() is designed to turn information from a configuration file into a usable KeySet, this is technically the only function that is REQUIRED in a plug-in.

elektraPluginSet() is designed to store the information from the keyset back into a configuration file.

elektraPluginClose() is used to free resources that might be required for the plug-in.

Most simply put: most plug-ins consist of four major functions, elektraPluginOpen(), elektraPluginClose(), elektraPluginGet(), and elektraPluginSet().

The next step to writing a plug-in is the contract. The contract basically just describes the plug-in. The main part of the contract describes to Elektra how it will modify the KeySet <em>returned. </em>This is what allows Elektra to work with various types of plug-ins. This guide will focus on one type of plug-in: the <em>storage</em> plug-in.

We already have <a title="documentation on plug-ins in our repository" href="https://github.com/ElektraInitiative/libelektra/blob/master/doc/CONTRACT.ini" target="_blank">documentation on plug-ins on our repository</a> but I will reiterate the details here. The first part of the contract you will need is the system/elektra/modules/Plugin (where Plugin represents the name of your plug-in). All this key does is let elektra know that your plug-in exists. The next key is system/elektra/modules/Plugin/exports. This key lets elektra know that your plug-in exports symbols to Elektra. Below this key you need to create keys for each function you want to export, in my line plug-in I implemented functions for get and set so I will create two keys as follows:<code>
keyNew ("system/elektra/modules/line/exports/get",
KEY_FUNC, elektraLineGet, KEY_END),
keyNew ("system/elektra/modules/line/exports/set",
KEY_FUNC, elektraLineSet, KEY_END),
</code>

So far we have told Elektra that our plugin exists and will be exporting functions for getting and setting keys. The next set of keys are the system/elektra/Plugin/infos keys. These are pretty self-explanatory. The first three children of this key, author, license, and description are pretty self explanatory. The infos/provides key tells Elektra the type of plug-in that is being used, this will be "storage" for any storage plug-in (which is what this tutorial focuses on). The info/placements key tells Elektra which functions of the plug-in it should call. Since I implemented get and set in the line plug-in, I would set this key to "getstorage setstorage". Next is infos/needs and infos/reccommends, infos/needs should contain a list of plug-ins or providers that your plug-in needs to work. Otherwise this key needs to be sent to be blank "". infos/recommends works exactly like needs except that a plug-in that needs another plug-in won't be compiled if the other plug-in doesn't exist but if it only recommends having the other plug-in, it will still compile in the others absence.

Since elektraPluginGet() is the only required function of a plug-in, this is where the plug-in's contract get exported into the Elektra key database. In my plugin, line, here is the contract is exported:
<code>int elektraLineGet(Plugin *handle ELEKTRA_UNUSED, KeySet *returned, Key *parentKey)
 {
 //Export the contract
 if (!strcmp (keyName(parentKey), "system/elektra/modules/line"))
 {
 KeySet *moduleConfig = ksNew (30,
 keyNew ("system/elektra/modules/line",
 KEY_VALUE, "line plugin waits for your orders", KEY_END), 
 keyNew ("system/elektra/modules/line/exports", KEY_END),
 keyNew ("system/elektra/modules/line/exports/get", //Specify which function to use for get
 KEY_FUNC, elektraLineGet, KEY_END),
 keyNew ("system/elektra/modules/line/exports/set", //Specify function to use for set
 KEY_FUNC, elektraLineSet, KEY_END),
 keyNew ("system/elektra/modules/line/infos",
 KEY_VALUE, "All information you want to know", KEY_END),
 keyNew ("system/elektra/modules/line/infos/author",
 KEY_VALUE, "Ian Donnelly &lt;ian.s.donnelly@gmail.com&gt;", KEY_END),
 keyNew ("system/elektra/modules/line/infos/licence",
 KEY_VALUE, "BSD", KEY_END),
 keyNew ("system/elektra/modules/line/infos/description",
 KEY_VALUE, "Very simple storage which writes out line by line", KEY_END),
 keyNew ("system/elektra/modules/line/infos/provides", //The type of plugin (should probably be storage)
 KEY_VALUE, "storage", KEY_END),
 keyNew ("system/elektra/modules/line/infos/placements", //Because this plugin is a storage plugin that impliments get and set
 KEY_VALUE, "getstorage setstorage", KEY_END),
 keyNew ("system/elektra/modules/line/infos/needs",
 KEY_VALUE, "", KEY_END),
 keyNew ("system/elektra/modules/line/infos/version",
 KEY_VALUE, PLUGINVERSION, KEY_END),
 KS_END);
 ksAppend (returned, moduleConfig);
 ksDel (moduleConfig);
 return 1;
 }
 return 1; /* success */
 }</code>
So Part 1 of the tutorial covers the implementation details for a plug-in as well as the basics of the plug-in contract. For more information about plug-ins and more detailed examples I highly suggest reading <a title="Markus' Thesis for Elektra" href="www.libelektra.org/ftp/elektra/thesis.pdf" target="_blank">Markus' Thesis for Elektra.</a> Chapter 4, which starts on page 61 goes into much more detail on Plug-Ins and explains the various features of the contracts. Look for Part 2 soon!

Sincerely,

Ian