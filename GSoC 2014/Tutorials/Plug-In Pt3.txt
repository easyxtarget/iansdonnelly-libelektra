Hi Everybody!

Hope you have been enjoying my tutorial on writing plug-ins so far. In Part 1 we covered the basic overview of a plug-in. Part 2 covered a plug-in's contract and the best way to write one. Now, for Part 3 we are going to cover the meat of a plug-in, the actual coding. As you should know from reading Part 1, there are five main functions used for plug-ins, elektraPluginOpen, elektraPluginGet, elektraPluginSet, ELEKTRA_PLUGIN_EXPORT(Plugin), where Plugin should be replaced with the name of your plug-in. We are going to start this tutorial by focusing on the elektraPluginGet because it usually is the most critical function.

As we discussed before, <code>elektraPluginGet</code> is the function responsible for turning information from a file into a usable KeySet. This function usually differs pretty greatly between each plug-in. This function should be of type int, it returns 0 on success or another number on an error. The function will take in a Key, usually called parentKey which contains a string containing the path to the file that is mounted. For instance, if you run the command <code>kdb mount /etc/linetest system/linetest line</code> then keyString(parentKey) should be equal to "/etc/linetest". At this point, you generally want to open the file so you can begin saving it into keys. Here is the trickier part to explain. Basically, at this point you will want to iterate through the file and create keys and store string values inside of them according to what your plug-in is supposed to do. I will give a few examples of different plug-ins to better explain.

My line plug-in was written to read files into a KeySet line by line using the newline character as a delimiter and naming the keys by their line number such as (line01, line02, .. line 22) for a file with 22 lines. So once I open the file given by parentKey, every time a I read a line I create a new key, let's call it new_key using dupKey(parentKey). Then I set new_keys's name to lineNN (where NN is the line number) using <code>keyAddBaseName</code> and store the string value of the line into the key using <code>keySetString</code>. Once the key is initialized, I append it to the KeySet that was passed into the elektraPluginGet function, let's call it returned for now, using <code>ksAppendKey(return, new_key)</code>. Now the KeySet will contain new_key with the name lineNN properly saved where it should be according to the <code>kdb mount</code> command (in this case, system/linetest/lineNN), and a string value equal to the contents of that line in the file. MY plug-in repeats these steps as long as it hasn't reached end of file, thus saving the whole file into a KeySet line by line.

The simpleini plug-in works similarly, but it parses for ini files instead of just line-by-line. At their most simple level, ini files are in the format of <code>name=value</code> with each pair taking one line. So for this plug-in, it makes a lot of sense to name each Key in the KeySet by the string to the left of the "=" sign and store the value into each key as a string. For instance, the name of the key would be "name" and <code>keyGetString(name)</code> would return "value". <code>
</code>

As you may have noticed, simpleini and line plug-ins work very similarly. However, they just parse the files differently. The simpleini plug-in parses the file in a way that is more natural to ini file (setting the key's name to the left side of the equals sign and the value to the right side of the equals sign.) The <code>elektraPluginGet</code> function is the heart of a storage plug-in, its what allows Elektra to store configurations in it's database. This function isn't just run when a file is first mounted, but whenever a file gets updated, this function is run to update the Elektra Key Database to match.

We also gave a brief overview of <code>elektraPluginSet</code> function. This function is basically the opposite of <code>elektraPluginGet</code>. Where <code>elektraPluginGet</code> reads information from a file into the Elektra Key Database, <code>elektraPluginSet</code> writes information from the database back into the mounted file. The implementation of <code>elektraPluginSet</code> for my line plug-in is particularly simple and will serve as a good example, the code is as follows:
<code>
int elektraLineSet(Plugin *handle ELEKTRA_UNUSED, KeySet *returned, Key *parentKey)
{
/* set all keys */
FILE *fp = fopen(keyString(parentKey), "w");
if (!fp)
{
ELEKTRA_SET_ERROR(74, parentKey, keyString(parentKey));
return -1;
}
Key *cur;
ksRewind (returned);
while ((cur = ksNext(returned)) != 0)
{
fprintf (fp, "%s\n", keyString(cur));
}
fclose (fp);
return 1; /* success */
}
</code>
As you can see, all <code>elektraLineSet</code> does is open a file, take each Key from the KeySet (remember they are named line01, line02 ... line22) in order, and write each key as it's own line in the file. Since we don't care about the name of the Key in this case (other than for order), we just write the value of keyString for each Key as a new line in the file. That's it. Now, each time the mounted KeySet is modified, <code>elektraPluginSet</code> will be called and the mounted file will be updated.

The <code>elektraPluginOpen</code> and <code>elektraPluginClose</code> functions are not commonly used for storage plug-ins, but they can be useful and are worth reviewing. <code>elektraPluginOpen</code> function runs before <code>elektraPluginGet</code> and is useful to do initialization if necessary for the plug-in. On the other hand <code>elektraPluginClose</code> is run after other functions of the plug-in and can be useful for freeing up resources.

The last function, one that is always needed in a plug-in, is <code>ELEKTRA_PLUGIN_EXPORT</code>. This functions is responsible for letting Elektra know that the plug-in exists and which methods it implements. The code from my line function is a good example and pretty self-explanatory:
<code>
 Plugin *ELEKTRA_PLUGIN_EXPORT(line)
{
	return elektraPluginExport("line",
		ELEKTRA_PLUGIN_GET,	&elektraLineGet,
		ELEKTRA_PLUGIN_SET,	&elektraLineSet,
		ELEKTRA_PLUGIN_END);
}
</code>

There you have it! This is the last part of my tutorial on writing a storage plug-in for Elektra. Hopefully you now have a good understanding of how Elektra plug-ins work and you'll be able to add some great functionality into Elektra through development of new plug-ins. I hope you enjoyed this tutorial and if you have any questions just leave a comment! Happy coding!