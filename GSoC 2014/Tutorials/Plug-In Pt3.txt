
Hi Everybody!

Hope you have been enjoying my tutorial on writing plug-ins so far. In Part 1 we covered the basic overview of a plug-in. Part 2 covered a plug-in's contract and the best way to write one. Now, for Part 3 we are going to cover the meat of a plug-in, the actual coding. As you should know from reading Part 1, there are five main functions used for plug-ins, elektraPluginOpen, elektraPluginGet, elektraPluginSet, ELEKTRA_PLUGIN_EXPORT(Plugin), where Plugin should be replaced with the name of your plug-in. We are going to start this tutorial by focusing on the elektraPluginGet because it usually is the most critical function.

As we discussed before, elektraPluginGet is the function responsible for turning information from a file into a usable KeySet. This function usually differs pretty greatly between each plug-in. This function should be of type int, it returns 0 on success or another number on an error. The function will take in a Key, usually called parentKey which contains a string containing the path to the file that is mounted. For instance, if you run the command kdb mount /etc/linetest system/linetest line then keyString(parentKey) should be equal to "/etc/linetest". At this point, you generally want to open the file so you can begin saving it into keys. Here is the trickier part to explain. Basically, at this point you will want to iterate through the file and create keys and store string values inside of them according to what your plug-in is supposed to do. I will give a few examples of different plug-ins to better explain.

My line plug-in was written to read files into a KeySet line by line using the newline character as a delimiter and naming the keys by their line number such as (line01, line02, .. line 22) for a file with 22 lines. So once I open the file given by parentKey, every time a I read a line I create a new key, let's call it new_key using dupKey(parentKey). Then I set new_keys's name to lineNN (where NN is the line number) using keyAddBaseName and store the string value of the line into the key using keySetString. Once the key is initialized, I append it to the KeySet that was passed into the elektraPluginGet function, let's call it returned for now, using ksAppendKey(return, new_key). Now the KeySet will contain new_key with the name lineNN properly saved where it should be according to the kdb mount command (in this case, system/linetest/lineNN), and a string value equal to the contents of that line in the file. MY plug-in repeats these steps as long as it hasn't reached end of file, thus saving the whole file into a KeySet line by line.

The simpleini plug-in works similarly, but it parses for ini files instead of just line-by-line. At their most simple level, ini files are in the format of name=value with each pair taking one line. So for this plug-in, it makes a lot of sense to name each Key in the KeySet by the string to the left of the "=" sign and store the value into each key as a string. For instance, the name of the key would be "name" and keyGetString(name) would return "value". 


The simpleini and line plug-ins work very similarly. However, they just parse the files differently. The simpleini plug-in parses the file in a way that is more natural to ini file (setting the key's name to the left side of the equals sign and the value to the right side of the equals sign.) The elektraPluginGet function is the heart of a storage plug-in, its what allows Elektra to store configurations in it's database.

We also gave a brief overview of elektraPluginSet function. This function is basically the opposite of elektraPluginGet. Where elektraPluginGet reads information from a file into the Elektra Key Database, elektraPluginSet writes information from the database back into the mounted file. The implementation of elektraPluginSet for my line plug-in is particularly simple and will serve as a good example, the code is as follows:

 int elektraLineSet(Plugin *handle ELEKTRA_UNUSED, KeySet *returned, Key *parentKey)
 {
 /* set all keys */
 FILE *fp = fopen(keyString(parentKey), "w");
 if (!fp)
 {
ELEKTRA_SET_ERROR(74, parentKey, keyString(parentKey));
 return -1;
 }
 Key *cur;
 ksRewind (returned);
 while ((cur = ksNext(returned)) != 0)
 {
 fprintf (fp, "%s\n", keyString(cur));
 }
 fclose (fp);
 return 1; /* success */
 }

 As you can see, all elektraLineSet does is open a file, take each Key from the KeySet (remember they are named line01, line02 ... line22) in order, and write each key as it's own line in the file. Since we don't care about the name of the Key in this case (other than for order), we just write the value of keyString for each Key as a new line in the file. That's it. Now, each time the mounted KeySet is modified, elektraPluginSet will be called and the mounted file will be updated.
