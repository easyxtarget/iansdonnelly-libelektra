Hi Everybody!

Hope you have been enjoying my tutorial on writing plug-ins so far. In Part 1 we covered the basic overview of a plug-in. Part 2 covered a plug-in's contract and the best way to write one. Now, for Part 3 we are going to cover the meat of a plug-in, the actual coding. As you should know from reading Part 1, there are five main functions used for plug-ins, elektraPluginOpen, elektraPluginGet, elektraPluginSet, ELEKTRA_PLUGIN_EXPORT(Plugin), where Plugin should be replaced with the name of your plug-in. We are going to start this tutorial by focusing on the elektraPluginGet because it usually is the most critical function.

As we discussed before, elektraPluginGet is the function responsible for turning information from a file into a usable KeySet. This function usually differs pretty greatly between each plug-in. This function should be of type int, it returns 0 on success or another number on an error. The function will take in a Key, usually called parentKey which contains a string containing the path to the file that is mounted. For instance, if you run the command <code>kdb mount /etc/linetest system/linetest line</code> then keyString(parentKey) should be equal to "/etc/linetest". At this point, you generally want to open the file so you can begin saving it into keys. Here is the trickier part to explain. Basically, at this point you will want to iterate through the file and create keys and store string values inside of them according to what your plug-in is supposed to do. I will give a few examples of different plug-ins to better explain.

My line plug-in was written to read files into a KeySet line by line using the newline character as a delimiter and naming the keys by their line number such as (line01, line02, .. line 22) for a file with 22 lines. So once I open the file given by parentKey, every time a I read a line I create a new key, let's call it new_key using dupKey(parentKey). Then I set new_keys's name to lineNN (where NN is the line number) using <code>keyAddBaseName</code> and store the string value of the line into the key using <code>keySetString</code>. Once the key is initialized, I append it to the KeySet that was passed into the elektraPluginGet function, let's call it returned for now, using <code>ksAppendKey(return, new_key)</code>. Now the KeySet will contain new_key with the name lineNN properly saved where it should be according to the <code>kdb mount</code> command (in this case, system/linetest/lineNN), and a string value equal to the contents of that line in the file. MY plug-in repeats these steps as long as it hasn't reached end of file, thus saving the whole file into a KeySet line by line.

The simpleini plug-in works similarly, but it parses for ini files instead of just line-by-line. At their most simple level, ini files are in the format of <code>name=value</code> with each pair taking one line. So for this plug-in, it makes a lot of sense to name each Key in the KeySet by the string to the left of the "=" sign and store the value into each key as a string. For instance, the name of the key would be "name" and <code>keyGetString(name)</code> would return "value". The code for elektraSimpleiniGet, after the contract declaration, is as follows:
<code>
int n;
char *key;
char *value;
FILE *fp = fopen (keyString(parentKey), "r");
if (!fp)
{
return 0; // we just ignore if we could not open file
}
while ((n = fscanf (fp, "%ms = %ms\n", &amp;key, &amp;value)) &gt;= 1)
{
Key *read = keyNew(0);
if (keySetName(read, key) == -1)
{
fclose (fp);
keyDel (read);
ELEKTRA_SET_ERROR(59, parentKey, key);
return -1;
}
keySetString(read, value);
ksAppendKey (returned, read);
free (key);
free (value);
}
if (feof(fp) == 0)
{
fclose (fp);
ELEKTRA_SET_ERROR(60, parentKey, "not at the end of file");
return -1;
}
fclose (fp);
return 1; /* success */
}</code>

You can see here that simpleini and line work very similarly. However, they just parse the files differently. The simpleini plug-in parses the file in a way that is more natural to ini file (setting the key's name to the left side of the equals sign and the value to the right side of the equals sign.)
