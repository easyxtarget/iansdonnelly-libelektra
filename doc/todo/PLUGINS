Ideas for new PLUGINS in elektra.
Prefer using great frameworks to do that in short time with high quality.


# Information Plugins #

Idea: expose information of OS or Elektra to the user.

## export BUILD INFORMATION ##

similar to KDB_VERSION constants, all other CMake constants of the
elektra installation should be included in a plugin like version


## Contract on Plugin configuration ##

do not only depend on "provides" but on configuration another plugin
provides. This option would allow to add multiple plugins with same
functionality, but only one is configured to do it actually.
* type checker
* encoding

Contract-Checker (linking against libtools) should be plugin too
	makes sure only valid backend configurations are written


## OS abstraction ##

chdir/getcwd
chroot
hostname
uname also to set
ulimit

Shell expansion
Environment expansion




# Helper plugins #

## name conversion ##

rename plugin

trim
encoding

Namecencode
nameutf8encode
namehexencode

make name lowercase
	(case sensitivity can be error prone)

rebase: remove/add a common prefix after parentKey
	cut of common basename below mountpoint), e.g. with config
rebase=org/freedesktop/openicc
system/org/freedesktop/openicc/org/freedesktop/openicc/device ->
system/org/freedesktop/openicc/device

Additional interesting features: trim, lowercase, arbitrary recodings
via python/lua function

recode of names (using iconv)


## fix Limitations ##

Idea: fix limitations of current plugins using other plugins

Needed for yajl: rewrite of values in directories as subkeys
rewrite of metadata to keys

fstab:
	support for spaces and so on (with \040)

## add Limitations ##

allow to lock down configuration for guis



# Storage plugins #

## Generic ##

Build a generic storage plugin to replace dump:
- preserving order
- preserving comments
- human read+writeable


## JSON ##

* should handle cppcms config files
  http://cppcms.com/wikipp/en/page/cppcms_1x_config
* should handle openicc
  doc/standards/OpenICC_device_config_DB.json
  http://www.freedesktop.org/wiki/Specifications/icc_meta_tag_for_monitor_profiles

http://json-schema.org

## HOSTS ##

does not fully support ipv6
canonical_name is not canonical anymore
(solve by having ipv4 and ipv6 subhierarchies?)

## PRETTY ##

latex plugin to make pretty printed key/value pairs
dot/graphviz plugin to visualize graph of keys
html plugin (to show elektra config in html format)
csv plugin with metadata as additional columns (configureable)

literate data
	good for documentation
	everything is ignored except special introduced key/value pairs
	<start><key><seperator><value><terminator>
	needs two more special characters next to seperator, but is
	otherwise alike

## self written ##

linenumber plugin
	just store every line of a file in an array

filesys:
	reintroduce? (useful for 0.7 migrations)
	empty folder will not show up (only with %%dirdata)
	Dirdata richtig escapen
	Metadata reinschreiben
	remove keys the new way
	compare sets between current and desired state (set operations)
	could be default-storage plugin, integrated resolver for previous siutation

## library supported ##

xpath plugin:
	on an xml file with an mapping from (reduced) xpath<->elektra keys

C/C++ serialization
	(ksNew(keyNew()))
	reading with llvm?

libconfig
eet
tdb.samba (using tdb_traverse)

/etc/groups plugin

other file formats:
	xfree
	apache
	kde-ini
	gconf
	xml
	inittab

tcl:
	parse output?
	struct output!

compile lenses as plugin:
	+ no dependency at runtime
	+ may be faster?

## ERROR ##

ignore_error plugin:
	transform error of a plugin to a warning






# FILTER Plugins #

Forensic Logging:
	environment, pid, gid, uid
	timezone + in ms
	IP

filter: key
	metadata lÃ¶schen
	hidden keys


advanced:
	hash sum
	signing
	encrypting
	binding

base64 encoding (and reverse)

libgcryt (LGPL, GPLv3?) used by cppcms

infer links between configuration (user/a=@user/b)
	and copy values


## RESTRICTIONs ##

restrict plugins to be written to
plugin: readonly (do not allow to be written to backend)


## METAREWRITE plugin ##

meta data rewriter into value
replaces NULL plugin

binary, type and any other meta data
encoded into string value
also encode null value (only possible in binary)
and binary (including encoding of null bytes and terminating null?)


## TYPE ##

struct: checker
	cannot be deeply nested
	don't throw char*
	check arrays

Checkers:
	check if hosts are reachable (e.g. by ping)

units-of-measurements (e.g. m, kg, A, ..)


# RESOLVER #

## split up ##

resolver-debug for tests
	concurrency: sets breakpoints within
	folder: write into folders controlled by env, maybe xdg
resolver-xdg-passwd
	use passwd with XDG overides
resolver-xdg
	use $HOME with XDG overides
resolver-hardcoded (just use KDB_DB_* for single users embedded systems)
resolver-passwd
resolver-posix
	using HOME def. in posix: http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html
	using USER as fallback? not def. in posix, but often in shells


## improvements ##

better error messages:
	#9 (when opening file failed)
	resolver in kdbError should correct error message
	the storage plugins do not have to state reason then

race conditions:
	the losing process must not remove the .tmp file, but it
	has to remove all .tmp files it created before (in those cases
		it won)
	-> needs also some logic within kdbSet() to handle this

use nanoseconds timestamps, maybe avoid locking completely
fsync the directory

make explicit state variable (for both user+system) or return fd!=-1

remove files on empty keysets (also needs logic in kdbSet())

tmp files:
	thread ID + randomness?

resolver:
	configureable flush+locking

kdb file
	using resolver plugin without function! (parent value!)
	should be returned in kdbGet/kdbSet?

XDG specification:
	write a xdg plugin which does xdg conforming resolving
	XDG_CONFIG_HOME
	describe, implement, test
	xdg mail announce


## SYNC plugin ##

fsync the file in keyname
abort on error (needs to be pre-commit)





# Improve the plugin system itself #

## global plugins ##

needed for

- global constraints and type checking
- single notifications per kdbGet/kdbSet


## VERSION IN CONTRACT ##

Configure file for plugin.h
with defines for verbosity, configuration, version numbers + contract in
static inline function
with licence, author in contract
Everything also in constants/build_info
add dependencies in contract?


## plugin commands ##

metadata that is evaluated by plugins

selective commit phases:
	define phases, minimum:
	commit
	check

norecursive:
	only fetch a single plugin without recursion


## DISTRIBUTOR BACKENDS ##

can be used as default using symlinks

1.st level citizen
	allow resolver only (one plugin for backend to be able to hierarchically stack backends)
	share modules globally (to allow loading of module within module)

mount: current implementation
mount-mpi: current implementation, but multithreaded
filesystem: implementation compatible with 0.7
lazy-mount
bind-mount
owner support
user-mount

do not hardcode 10 plugins (rationale?)


## DEFAULT PLUGINS ##

default plugin handling: resolver/storage

policy how default storage & resolver plugin are named
resolve the symlink and load the module with correct name

is meta data in default plugin needed?
	add rewrite plugins?

default storage plugin:
	changeable
	nickel with meta in [] sections?

DEFAULT_BACKEND ->
	DEFAULT_STORAGE_PLUGIN
	DEFAULT_RESOLVER_PLUGIN
	(+ make it work)
	good out-of-the-box behaviour

## CPPPLUGIN ##

cppplugin:
	make a nice and easy cpp solution for plugins
	(integration into cpp binding)
	assemble C symbols with macros
	keep C->C++ problems at one place to be included

C++: (FINISH cppplugin)
	how to write backends in C++
	Exceptions propagations
	(C++ Exceptions to error codes)
